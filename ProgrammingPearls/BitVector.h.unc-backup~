#ifndef ACRUSH_BITVECTOR_H
#define ACRUSH_BITVECTOR_H

// size of int
#define SIZEPERWORD 32

// 2^5 is 32 and shifting int by 5 to the right is to divide it by 32
// which will be helpful when converting bit index to index in the int array
#define SHIFT 5

// 0x1f is 00011111 == 31
#define MASK 0x1f

class BitVector {
public:
    BitVector(const size_t& sz) : size((sz >> SHIFT) + 1) {
        // sz>>SHIFT+1 converts number of bits to number of int
        a = new int[size];
        memset(a, 0, sz);
    }
private:
    int* a;
    size_t size;
};



    void set(const size_t& i) {
        // first find the index in a (integer index) using i (number of bits)
        // a[i>>SHIFT+1] is the location of integer that contains the i-th bit
        // second find the bit inside of this integer, we mod i by 32
        // i&MASK will get the last 5 bits in i which is equvalent to moding it
        // by 32 Now we have the mask and the correct location to place the mask
        // we move the mask to the right int slot where i-th bit belongs
        // and do binary OR to set bit

        a[i >> SHIFT] |= (1 << (i & MASK));
    }

    void clr(const size_t& i) {
        // pretty much the same as set
        // but this time we get the opposite value and do bitwise AND to clear
        // bits
        a[i >> SHIFT] &= ~(1 << (i & MASK));
    }

    int test(const size_t& i) {
        // see if the ith bit is turned on
        return a[i >> SHIFT] & (1 << (i & MASK));
    }

    ~bitVector() {
        // cout << "removing bitVector...\n";
        delete a;
    }

#endif //ACRUSH_BITVECTOR_H
